## Explicaciones por cada ejercicio
### Ejercicio 1: 
Las clases cumplen con los requisitos del ejercicio al implementar el patrón Adapter para conectar ThirdPartyAudioPlayer con la interfaz MusicPlayer. La clase AudioPlayerAdapter actúa como un adaptador, permitiendo que el reproductor externo, que usa el método startAudio, funcione con la interfaz MusicPlayer, que requiere el método playSong. Este diseño traduce las llamadas de métodos entre sistemas sin modificar el código de ThirdPartyAudioPlayer, cumpliendo así con la condición de no alterar la clase existente. La clase MusicApp utiliza el adaptador para reproducir canciones tanto con un reproductor nativo como con el de terceros, lo que demuestra que ambos sistemas pueden trabajar juntos de manera eficiente. Además, el diagrama de clases muestra claramente esta estructura, facilitando la comprensión de las relaciones y funciones entre las clases.
![imagen1](https://github.com/lazamartinez/2024-poo2-ejercicio3-primeraparte/blob/main/2024-tp3-primeraparte/ejercicio1/Ejercicio1.png)

### Ejercicio 2: 
El código está bien hecho para el ejercicio del patrón Composite porque trata archivos y directorios de la misma manera usando la clase base abstracta FileSystemComponent. Esta clase tiene un método showDetails() que se sobrescribe en las clases File y Directory, permitiendo manipular archivos y directorios de forma uniforme. La clase Directory puede tener una lista de componentes FileSystemComponent, lo que le permite agregar y eliminar archivos y otros directorios. Además, su método showDetails() usa recursividad para mostrar todos sus contenidos, facilitando la visualización de la estructura jerárquica. Así, la implementación cumple con el patrón Composite, gestionando un conjunto de objetos que comparten la misma interfaz.
![imagen1](https://github.com/lazamartinez/2024-poo2-ejercicio3-primeraparte/blob/main/2024-tp3-primeraparte/ejercicio2/Ejercicio2.png)

### Ejercicio 3: 
El código cumple con las condiciones del ejercicio al implementar el patrón Template Method a través de la clase abstracta Cake, que define el proceso general para hacer pasteles mediante el método makeCake(), mientras que los pasos específicos, como prepareIngredients() y decorateCake(), se delegan a las subclases ChocolateCake y VanillaCake. Esto permite que cada tipo de pastel tenga su propia lógica de preparación y decoración, garantizando así la flexibilidad requerida. La clase CakeShopClient, que actúa como cliente, no está vinculada a las demás clases mediante una relación de herencia o composición, ya que su única función es instanciar objetos de las subclases y utilizar su método makeCake(), sin alterar la lógica interna de la fabricación de pasteles.
![imagen1](https://github.com/lazamartinez/2024-poo2-ejercicio3-primeraparte/blob/main/2024-tp3-primeraparte/ejercicio3/Ejercicio3.png)
